; vim: ft=querifier ts=2 sts=2 sw=2 et:

(let
  ((message-ptr-fmt (quote (ptr %host:#string %id:#string %hash:#string)))

   (auditorium-message-fmt (quote 
        (announce (host %id:#string %addr:#string %port:#string)
                  %seqno:#string
                  %message:#any)))

   (cert-fmt (quote
          (cert (signature %cert-signer:#string
                           %cert-sig-data:#string
                           %key:(key #string #string #string #string)))))

   (signed-message-fmt (quote
        (signed-message 
          %cert:#any
          (signature %signer:#string %sigdata:#string %payload:#any))))

   (signature-fmt (quote 
        (signature %signer:#string %sigdata:#string %payload:#any)))

   (key-fmt (quote (key %keyid:#string %keynote:#string
                             %keymod:#string %keyexp:#string)))

   (signed-message-cert-fmt (quote
        (signed-message 
          (cert (signature %cert-signer:#string
                           %cert-sig-data:#string
                           %key:(key #string #string #string #string)))
          (signature %signer:#string %sigdata:#string %payload:#any))))

   (signed-auditorium-message-fmt (quote ; the whole shebang all at once
        (announce (host %id:#string %addr:#string %port:#string)
                  %seqno:#string
                  (signed-message 
                    (cert (signature %cert-signer:#string
                                     %cert-sig-data:#string
                                     %key:(key #string #string #string #string)))
                    (signature %signer:#string %sigdata:#string 
                      (succeeds %preds:#list:(ptr #string #string #string)
                                %payload:#any))))))

    ;; message payload formats
    ; see https://sys.cs.rice.edu/votebox/trac/wiki/VotingMessages
  
    ;; core election messages
    (polls-open-fmt (quote (polls-open %timestamp:#string %keyword:#string)))
    (polls-closed-fmt (quote (polls-closed %timestamp:#string)))

    (ballot-auth-fmt (quote (authorized-to-cast-with-nizks %nodeid:#string %nonce:#any %ballot-data:#any %precinct:#string %publicKey:#any)))
    (ballot-received-fmt (quote (ballot-received %nodeid:#string %nonce:#any %bid:#string %precinct:#string)))
    (cast-ballot-fmt (quote (encrypted-cast-ballot-with-nizks %nonce:#string %cast-ballot-data:#any %bid:#string)))

    ;; election maintenance messages
    (assign-label-fmt (quote (assign-label %nodeid:#string %label:#string)))
    (super-status-fmt (quote (supervisor %timestamp:#string %status:#string)))
    ; (booth-status-fmt (quote (booth %timestamp:#string %status:#string)))
    (super-activated-fmt (quote (activated %statuses:#list:#any)))

    ; supervisor recovery messages
    ;(polls-open-query-fmt (quote (polls-open? %keyword:#string)))
    ;(last-polls-open-fmt (quote (last-polls-open (polls-open %polls-open-msg:#any))))
    
    ;; messages for vote overrides (initiated by supervisor)
    (override-cancel-fmt (quote (override-cancel %nodeid:#string %nonce:#string)))
    (override-cancel-confirm-fmt (quote (override-cancel-confirm %nonce:#string)))
    (override-cancel-deny-fmt (quote (override-cancel-deny %nonce:#string)))
    (override-cast-fmt (quote (override-cast %nodeid:#string %nonce:#string)))
    (override-cast-confirm-fmt (quote (override-cast-confirm %nonce:#string)))
    (override-cast-deny-fmt (quote (override-cast-deny %nonce:#string)))
  )


  ;; rules
  (and (

    ; RULE: all messages must be valid and signed
;    (forall x all-set (let-match auditorium-message-fmt x true false))
    (let
      ((result (forall x all-set (let-match signed-auditorium-message-fmt x
      true false))))
      (and (
        (print ((quote ALL_VALID_MESSAGES) result))
        result)))

    ; RULE: there must be a polls-open message
    (let ((result
    (exists x all-set
          (let-match signed-auditorium-message-fmt x
                     (let-match polls-open-fmt payload true false)
                     false))
    ))
    (and (
      (print ((quote POLLS_OPEN_EXISTS) result))
      result)))
;
;    ; RULE: there must be a polls-closed message
    (let ((result
    (exists x all-set
          (let-match signed-auditorium-message-fmt x
                     (let-match polls-closed-fmt payload true false)
                     false))
    ))
    (and (
      (print ((quote POLLS_CLOSED_EXISTS) result))
      result)))
;
;    ; RULE: polls-open must be succeeded by polls-closed
;    ; ** broken version: assumes polls-closed has a nonce
;    (forall x all-set
;      (let-match signed-auditorium-message-fmt x
;        (let-match polls-open-fmt payload
;          (let
;             ((nonce0 nonce)) ; save this nonce
;            (exists y all-set
;              (let-match signed-auditorium-message-fmt y
;                (let-match polls-closed-fmt payload
;                  (and
;                    ((= nonce nonce0)
;                     (precedes x y all-dag)))
;                   false)
;                false)))
;          false)
;        false))
;   ; ** corrected: no nonces to compare
    ; (let ((result
    ; (exists x all-set
    ;   (let-match signed-auditorium-message-fmt x
    ;     (let-match polls-open-fmt payload
    ;         (exists y all-set
    ;           (let-match signed-auditorium-message-fmt y
    ;             (let-match polls-closed-fmt payload
    ;                  (precedes x y all-dag)
    ;                  false)
    ;             false))
    ;       false)
    ;     false))
    ; )) 
    ; (and (
    ;   (print ((quote OPEN_THEN_CLOSE) result))
    ;   result)))
;
;    (print ((quote TrivialExistsTest)))
;
;    (exists x all-set true)
;
;    (print ((quote SlightlyMoreComplexExistsTest)))
;
;    (exists x all-set (and (true true true)))

;;    ; RULE: cast-ballot must be preceded by auth and succeeded by
;;    ; ballot-received
    ; (let ((result
    ; (forall ballot all-set
    ;   (let-match signed-auditorium-message-fmt ballot
    ;     (let-match cast-ballot-fmt payload
    ;       (let
    ;          ((cast-nonce nonce)) ; save this nonce
    ;         (let (
    ;           (result
    ;         (and (
    ;           ; must be preceded by auth
    ;           (let (( res (exists auth all-set
    ;             (let-match signed-auditorium-message-fmt auth
    ;               (let-match ballot-auth-fmt payload
    ;                 (let
    ;                     ((n_result (= nonce cast-nonce))
    ;                      (p_result (precedes auth ballot all-dag)))

    ;                   (and ((print ((quote NONCE) nonce))(print ((quote CAST_NONCE) cast-nonce)) n_result p_result)))
    ;                  false)
    ;               false)))) (and ((print ((quote A) res)) res)))
    ;           ; must be followed by receipt
    ;           (let ((res (exists receipt all-set
    ;             (let-match signed-auditorium-message-fmt receipt
    ;               (let-match ballot-received-fmt payload
    ;                 (and
    ;                   ((= nonce cast-nonce)
    ;                    (precedes ballot receipt all-dag)))
    ;                  false)
    ;               false)))) (and ((print ((quote B) res)) res)))
    ;           ; uniqueness: there must not exist a ballot with the same nonce
    ;           ; (unless it's this ballot)
    ;           (let ((res (not
    ;             (exists otherballot all-set
    ;               (let-match signed-auditorium-message-fmt otherballot
    ;                 (let-match cast-ballot-fmt payload
    ;                   (and (
    ;                     (= nonce cast-nonce)
    ;                     (not (= ballot otherballot))))
    ;                   false)

    ;                 false)))
    ;           )) (and ((print ((quote C) res)) res))
    ;                     )))))

    ;          (and (
    ;            (print ((quote LEGIT_BALLOT) result))
    ;            result))) ;end interior verbose let
    ;         ) ; end exterior let-cast-nonce
    ;       true) ;; if this message is not a ballot, this rule should return true
    ;     false)  ;; all messages should be valid signed messages 
    ;             ;; (redundant with earlier rule)
    ;   )
    ; )) 
    ; (and (
    ;   (print ((quote ALL_BALLOTS_AUTH_AND_CONFIRMED) result))
    ;   result)))

    ; TODO: not exists auth1 << auth2 << ballot1

  )) ; end of (and ...) rules
) ; end
